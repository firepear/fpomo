#!/usr/bin/env bash

# usage notification
fpctimer_help() {
cat <<EOF
usage: fpctimer <OPTIONS> [MINUTES]

  --alert [CMD]
    The command to run when time is up.
    Default: '${alert}'

  --count [NUM]
    How many times to run the alert cmd. Default: ${count}

  --mark [CHAR]
    Set the character which will be used to flood the screen and
    visually represent time remaining. Default: '${mark}'

  --sleep [SECS]
    How many seconds to sleep between screen updates. Default: ${sleep}

EOF
}

fpc_disptime() {
    mins=$(( timer_secs / 60 ))
    secs=$(( timer_secs % 60 ))
    printf '  %02d:%02d' ${mins} ${secs}
}

fpc_drawscreen() {
    cur_row=1

    # what percentage of time is remaining?
    tp=$(echo "scale=5; 1 - ${timer_elap} / ${total_secs}" | bc -l)
    # and so how many marks are remaining and how many will be blanked?
    marks_remaining=$(echo "scale=4; ${tot_marks} * ${tp}" | bc -l | cut -d'.' -f1)
    marks_blank=$(( tot_marks - marks_remaining ))
    clear
    while [[ ! "${cur_row}" -gt "${LINES}" ]]; do
        line=""
        cur_pos=$(( (cur_row - 1) * COLUMNS ))
        end_pos=$(( cur_pos + COLUMNS ))
        if [[ ! "${marks_blank}" -lt "${end_pos}" ]]; then
            # blank line
            for i in $(seq 1 ${COLUMNS}); do
                line="${line} "
            done
        elif [[ "${marks_blank}" -gt "${cur_pos}" ]] && [[ "${marks_blank}" -lt "${end_pos}" ]]; then
            # partial line
            line_marks=$(( end_pos - marks_blank ))
            if [[ "${debug}" == "true" ]]; then
                echo "mb:${marks_blank} cp:${cur_pos} ep:${end_pos} lm:${line_marks}"
            fi
            for i in $( seq 1 $(( COLUMNS - line_marks )) ); do
                line="${line} "
            done
            for i in $(seq 1 ${line_marks}); do
                line="${line}${mark}"
            done
        else
            # full line
            for i in $(seq 1 ${COLUMNS}); do
                line="${line}${mark}"
            done
        fi
        if [[ "${cur_row}" == "${LINES}" ]]; then
            echo "${line:0:$(( ${#line} - ${#disp_time} ))}${disp_time}"
        else
            echo "${line}"
        fi
        cur_row=$(( cur_row + 1 ))
    done
    if [[ "${debug}" == "true" ]]; then
        echo "L:${LINES} C:${COLUMNS} cur:${cur_row} ts:${timer_secs} te:${timer_elap} tp:${tp} tm:${tot_marks} mr:${marks_remaining} mb:${marks_blank} lm:${line_marks} cp:${cur_pos} ep:${end_pos}"
    fi
}

# set defaults
LINES=$(tput lines)
LINES=$(( LINES - 1 ))
COLUMNS=$(tput cols)
COLUMNS=$(( COLUMNS - 1 ))
fpc_config="${HOME}/.fpctimerrc"
debug="false"
mark='â‹…'
sleep=5
count=3
os=$(uname)
alert=""
if [[ "${os}" == "Darwin" ]]; then
    alert='afplay /System/Library/Sounds/Glass.aiff'
fi

# process args
while [[ "${1}" =~ ^- ]]; do
    case "${1}" in
        "--help")
            fpctimer_help
            exit 1
            ;;
        "--config")
            # TODO
            ;;
        "--debug")
            debug="true"
            ;;
        "--alert")
            alert="${2}"
            shift
            ;;
        "--count")
            count="${2}"
            shift
            ;;
        "--mark")
            mark="${2}"
            shift
            ;;
        "--sleep")
            sleep="${2}"
            shift
            ;;
        *)
            echo "unknown arg '${1}'. try '--help' for usage info"
            exit 1
            ;;
    esac
    shift
done

# last of all should come the number of minutes we want to run
# for. keep a copy for display purposes, but convert to seconds for
# internal use. also set elapsed time while we're here.
if [[ "${1}" == "" ]]; then
    echo "no timer value given; nothing to do."
    exit 0
fi
total_secs=$(( ${1} * 60 ))
timer_secs=${total_secs}
timer_elap=0
disp_time=$(fpc_disptime)
shift
# if we got passed something nonsensical (not a number) as a value,
# we'll get the answer zero. in that case, we can quit right now.
if [[ "${timer_secs}" == "0" ]]; then
    echo "no timer value given; nothing to do."
    exit 0
fi
# bail if bc isn't around
test=$(echo "5+5" | bc)
if [[ "${test}" != "10" ]]; then
    echo "error: 'bc' not found in path"
    exit 1
fi


# how many marks are gonna fit? first, work out the number of
# character cells on screen
tot_marks=$(( LINES * COLUMNS ))
# subtract the length of the time remaining
tot_marks=$(( tot_marks - ${#disp_time} ))

while [[ "${timer_secs}" -gt "0" ]]; do
    # turn our seconds count into minutes and seconds for display
    # purposes
    disp_time=$(fpc_disptime)
    # draw the screen
    fpc_drawscreen
    # subtract sleep period from timer
    if [[ "${timer_secs}" -ge "${sleep}" ]]; then
        timer_secs=$(( timer_secs - sleep ))
        timer_elap=$(( timer_elap + sleep ))
    else
        timer_elap=$(( timer_elap + timer_secs ))
        sleep="${timer_secs}"
        timer_secs=$(( timer_secs - sleep ))
    fi
    # snooze
    sleep ${sleep}
done

disp_time=$(fpc_disptime)
fpc_drawscreen
for i in $(seq 1 "${count}"); do
    if [[ "${alert}" != "" ]]; then
        ${alert}
    fi
done
